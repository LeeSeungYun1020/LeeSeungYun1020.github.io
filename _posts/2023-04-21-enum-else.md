---
layout: post
title: "enum에서 else 없애기"
tags: [ "class", "enum class", "control flow" ]
excerpt: "enum class를 사용할 때 else 브랜치를 없애 버려야 하는 이유를 알아봅니다."
---

## 들어가기

enum class를 when에서 사용할 때는 else 브랜치를 없애 버리자.  
when은 식으로 사용하여 완전성 검사를 수행하도록 하자.

enum 상수가 추가되면 컴파일 에러로 즉시 감지하여 분기 처리가 누락되었는지 바로 확인할 수 있다.

## else 사용

```kotlin
enum class Color {
    RED, GREEN, BLUE
}

fun test(color: Color) {
    when (color) {
        Color.RED -> println("red")
        Color.GREEN -> println("green")
        else -> println("blue")
    }
}
```

Color에 ORANGE 상수를 추가하면 어떻게 될까?  
blue가 출력된다.  
이를 방지하려면 else 브랜치 대신 Color.BLUE 상수를 사용해야한다.

## 없애버린 else

```kotlin
enum class Color {
    RED, GREEN, BLUE
}

fun test(color: Color) {
    when (color) {
        Color.RED -> println("red")
        Color.GREEN -> println("green")
        Color.BLUE -> println("blue")
    }
}
```

ORANGE가 추가되면 컴파일러가 에러를 발생시킨다.  
개발자가 어쩌다 처리를 빠뜨리더라도 컴파일러가 이런 실수를 잡아준다.

## null 처리

nullable 값도 when 식에서 처리 가능하다.  
마찬가지로 else 대신 null 값을 브랜치에 포함하여 처리할 수 있다.

```kotlin
enum class Color {
    RED, GREEN, BLUE
}

fun test(nullableColor: Color?) {
    when (nullableColor) {
        Color.RED -> println("red")
        Color.GREEN -> println("green")
        Color.BLUE -> println("blue")
        null -> println("error")
    }
}
```

또 다른 방법으로 null 값을 미리 처리하는 방법도 있다.

```kotlin
fun test(nullableColor: Color?) {
    nullableColor ?: return println("error")
    when (nullableColor) { // Color? -> Color로 스마트 캐스팅 된다.
        Color.RED -> println("red")
        Color.GREEN -> println("green")
        Color.BLUE -> println("blue")
    }
}
```

## 정리

else가 있는 경우

- 오류가 발생하지 않는다.
- 처리를 누락하여도 논리적 오류를 발견하기 전까지 알기 힘들다.

else가 없는 경우

- 컴파일 오류가 발생한다.
- 새로운 상수를 추가하면 빠뜨리지 않고 처리할 수 있다.

when에서 enum을 다룰 때는 else를 없애버리자.  
새로운 상수에 대한 처리를 누락할지라도 컴파일러가 나를 도와줄 것이다.  

