---
layout: post
title: "Android View Binding vs Data Binding 비교"
excerpt: "바인딩이 무엇인지, 뷰 바인딩과 데이터 바인딩은 어떤 기능인지 비교합니다."
tags: [ "binding", "app architecture", "view binding", "data binding" ]
---

## 바인딩 왜 사용하나?

바인딩을 사용하면 View 환경에서 findViewById를 대체할 수 있다.
findViewById 함수는 레이아웃 트리에서 id로 뷰를 탐색하기에 런타임 비용이 있고, 잘못된 참조는 실행 중 해당 View를 사용하려는 시점에야 발견된다.

무엇보다 큰 바인딩의 장점은 null과 type 안정성이다.  
바인딩을 사용하면 컴파일 시간, IDE의 도움을 받으면 그 이전에도 문제를 확인할 수 있다.

바인딩을 적용하면 XML 레이아웃 파일을 이용하여 뷰에 바로 접근할 수 있는 레퍼런스를 포함한 바인딩 클래스를 만들어 준다.  
바인딩 인스턴스를 이용하면 뷰에 바로 접근할 수 있으며, findViewById를 이용했을 때 필요한 보일러 플레이트를 제거할 수 있다.  
레이아웃 수정으로 View의 id가 삭제 또는 변경되어도 컴파일 시점에 확인할 수 있다.

## 데이터 바인딩과 뷰 바인딩

### 데이터 바인딩

데이터 바인딩은 다양한 기능을 지원한다.

- 설정한 모듈에서 layout 태그로 감싸진 레이아웃에 대해 바인딩 클래스 생성
    - `<layout>` 루트 필요
- 레이아웃 변수와 식
    - `<data>` 요소 내에 import, variable 선언 가능
    - `@{}` 형태로 식 삽입 가능
- 데이터 관찰하여 동적 UI 변경
    - `androidx.databinding.Observable(Type)`을 이용하여 동적으로 UI 변경
- 어댑터로 맞춤 속성 생성
    - `@BindingAdapter` 애너테이션으로 View에 맞춤 속성 추가
- 양방향 데이터 바인딩
    - `@={}`형태로 양방향 데이터 결합 - observable 형태로 값 변경 시 수신 가능

데이터 바인딩은 파싱 처리와 코드 생성 과정이 필요하여 상대적으로 컴파일 시간이 길고 레이아웃과 비즈니스 로직이 뒤섞여 레이아웃 파일의 복잡성이 증가하여 유지 보수가 어려워질 수
있다.

### 뷰 바인딩

뷰 바인딩은 데이터 바인딩에서 복잡성을 제거한 간략화 버전이다.  
각 XML 레이아웃마다 바인딩 클래스를 생성하여 뷰 참조를 제공한다.  
표현식, 동적 UI 변경 등은 지원하지 않지만 가볍고 빠르게 컴파일할 수 있으며 사용법이 단순하다.

## 정리

- 데이터 바인딩: 강력한 기능 제공, 레이아웃 복잡성, 컴파일 시간 증가, 유지 보수 부담
- 뷰 바인딩: 가볍고 단순, 안전한 뷰 참조 제공

데이터 바인딩이 먼저 출시되었기에 이전에 생성된 프로젝트라면 데이터 바인딩을 아직 사용하고 있을 수도 있다.  
무턱대고 데이터 바인딩을 모든 기능을 사용하려 하면 생산성을 해치고 가독성을 떨어뜨리는 결과를 초래할 수 있다.  
기존 프로젝트에 데이터 바인딩을 이미 사용 중이라면 신규 기능에는 뷰 참조 기능만 사용하고, 기존 화면 개선이 필요할 때 점진적으로 뷰 바인딩으로 전환하면 어떨까 싶다.

